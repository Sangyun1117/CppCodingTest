//🧾 문제 : 1377번 - 버블 소트(골드 2)
//문제
//버블 소트 알고리즘을 다음과 같이 C++로 작성했다.
//
//bool changed = false;
//for (int i = 1; i <= N + 1; i++) {
//	changed = false;
//	for (int j = 1; j <= N - i; j++) {
//		if (A[j] > A[j + 1]) {
//			swap(A[j], A[j + 1]);
//			changed = true;
//		}
//	}
//	if (changed == false) {
//		cout << i << '\n';
//		break;
//	}
//}
//위 소스에서 N은 배열의 크기이고, A는 정렬해야 하는 배열이다.
// 배열은 A[1]부터 사용한다.위와 같은 소스를 실행시켰을 때 어떤 값이 출력되는지 구해보자.
//단, 정렬을 수행하는 과정에서 어떤 두 수가 바뀌었다면,
// 그 시점을 정렬이 완료된 시점이 아니다.
// 위 소스에서는 i 번째 반복에서 정렬이 끝났다고 판단되면 i를 출력하고 종료하게 된다.
//
//예를 들어 3 2 1 이라는 입력이 있다면,
//
//1번째 반복 : 3 2 1 → 2 3 1 → 2 1 3
//
//2번째 반복 : 1 2 3 (이때 더 이상 swap이 일어나지 않음) → 출력은 3이 된다.
//
//입력
//첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100, 000)
//다음 N개의 줄에는 A[1] ~A[N]에 들어있는 수가 한 줄에 하나씩 주어진다.
//이 수들은 모두 1, 000, 000보다 작거나 같은 자연수이다.
//
//출력
//정렬이 완료된 시점에서의 i 값을 출력한다.
//
//예제 입력 1
//5
//10
//1
//5
//2
//3
//예제 출력 1
//3
//💡 핵심 아이디어
//버블 소트는 왼쪽에서 오른쪽으로 가장 큰 값을 뒤로 보내는 정렬이다.
//
//최악의 경우 모든 요소가 이동해야 하므로, 각 요소가 몇 칸 이동했는지 추적하면 정렬 완료 시점을 알 수 있다.
//
//A[i]의 원래 인덱스와 정렬 후 인덱스를 비교해서 가장 많이 이동한 값의 이동 거리를 계산하면, 정렬이 완료되는 루프 수를 알 수 있다.
//
//이때 필요한 반복 횟수는 최대 이동 거리 + 1이다. (+1은 버블소트 알고리즘 상 changed = false로 빠져나가는 반복이 1번 더 있기 때문)
//


#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
	int N;
	cin >> N;

    vector<pair<int, int>> A(N);
    for (int i = 0; i < N; ++i) {
        cin >> A[i].first;
        A[i].second = i; //A의 second는 정렬전 index
    }
    sort(A.begin(), A.end()); 

    int maxNum = 0;
    for (int i = 0; i < N; i++) { //i는 정렬 후 인덱스
        maxNum = max(A[i].second - i, maxNum); //정렬전 - 정렬후가 가장 큰 걸 찾기
    }

    cout << maxNum + 1; //문제 코드를보면 다 완전히 정렬되고나서 체크 한번 하므로 +1
}









