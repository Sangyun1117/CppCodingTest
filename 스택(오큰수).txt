//🧩 문제 이름 : 17298번 - 오큰수(골드 4)
//문제
//오큰수는 오른쪽에 있으면서 자기보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미합니다.
//예를 들어, [3, 5, 2, 7]에서 3의 오큰수는 5이고, 5의 오큰수는 7이며, 2의 오큰수는 7이다.
//7은 오른쪽에 큰 수가 없으므로 오큰수는 - 1이다.
//
//정수 N개로 이루어진 수열 A가 주어졌을 때, 모든 수에 대한 오큰수를 구하는 프로그램을 작성하세요.
//
//입력
//첫째 줄에 수열 A의 크기 N(1 ≤ N ≤ 1, 000, 000)이 주어진다.
//둘째 줄에는 A₁, A₂, ..., Aₙ이 주어진다. (1 ≤ Aᵢ ≤ 1, 000, 000)
//
//출력
//총 N개의 오큰수를 출력한다.
//A₁의 오큰수, A₂의 오큰수, ..., Aₙ의 오큰수를 공백으로 구분해 출력한다.
//
//예제 입력 1
//4
//3 5 2 7
// 
//예제 출력 1
//5 7 7 - 1
// 
//예제 입력 2
//4
//9 5 4 8
// 
//예제 출력 2
//- 1 8 8 - 1
// 
//💡 핵심 아이디어(스택 활용)
//오른쪽 값들을 확인하면서 "자기보다 큰 수"를 찾아야 하므로, 역방향으로 탐색하거나 스택을 활용하여 효율적으로 처리해야 합니다.
//
//스택에는 "인덱스"를 저장하고, 새로운 수가 스택의 top에 있는 수보다 크면, 그 수가 오큰수가 됩니다.
//
//✅ 시간복잡도
//시간복잡도 : O(N)
//각 원소가 스택에 한 번만 들어가고, 한 번만 빠지므로 O(N)에 해결 가능.







#include <iostream>
#include <stack>
#include <vector>
using namespace std;

int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int n;
	cin >> n;
	vector<int> a(n);
	stack<int> s;
	vector<int> oks(n); //오큰수 벡터
	for (int i = 0; i < n; i++) {
		cin >> a[i];
	}
	s.push(0);
	for (int i = 1; i < n; i++) {
		while (!s.empty() && a[s.top()] < a[i]) {
			oks[s.top()] = a[i];
			s.pop();
		}
		s.push(i);
	}

	while (!s.empty()) {
		oks[s.top()] = -1;
		s.pop();
	}
	for (int i = 0; i < n; i++) {
		cout << oks[i] << " ";
	}
}











