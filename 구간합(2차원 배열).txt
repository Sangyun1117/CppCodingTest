//🧩 백준 11660번 - 구간 합 구하기 5 (실버 1)
//🔗 https ://www.acmicpc.net/problem/11660
//
//📘 문제
//N×N개의 수가 있는 표가 있다.표의(i, j)는 i행 j열을 의미한다.
//표의 값은 입력으로 주어진다.
//
//그 다음, M개의 줄에 걸쳐서 표의 부분 합을 구하는 질문이 주어진다.
//각 질문은 네 개의 정수 x1, y1, x2, y2로 이루어져 있으며,
//(x1, y1)에서(x2, y2)의 합을 구해 출력해야 한다.
//
//(x1, y1)에서(x2, y2)의 합은
//표에서(x1, y1)부터(x2, y2)까지의 모든 수의 합을 의미한다.
//예를 들어, 다음과 같은 4×4 표가 있을 때,
//
//1 2 3 4
//2 3 4 5
//3 4 5 6
//4 5 6 7
//(2, 2)에서(3, 4)까지 합은
//3 + 4 + 5 + 4 + 5 + 6 = 27이다.
//
//📥 입력
//첫째 줄에 표의 크기 N과 합을 구해야 하는 횟수 M이 주어진다. (1 ≤ N ≤ 1, 024, 1 ≤ M ≤ 100, 000)
//둘째 줄부터 N개의 줄에는 N개의 수가 표에 채워져 있다.
//표에 채워져 있는 수는 1, 000보다 작거나 같은 자연수이다.
//
//그 다음 M개의 줄에는 네 개의 정수 x1, y1, x2, y2가 주어진다.
//(1 ≤ x1 ≤ x2 ≤ N, 1 ≤ y1 ≤ y2 ≤ N)
//
//📤 출력
//총 M개의 줄에 걸쳐(x1, y1)에서(x2, y2)의 합을 출력한다.
//
//🧪 예제 입력
//4 3
//1 2 3 4
//2 3 4 5
//3 4 5 6
//4 5 6 7
//2 2 3 4
//3 4 3 4
//1 1 4 4
//📟 예제 출력
//27
//6
//64
//🧠 핵심 아이디어
//* *2차원 누적합(Prefix Sum) * *을 활용해 빠르게 구간합 계산
//
//구간(x1, y1) ~(x2, y2) 구간합 공식 :
//
//S[x2][y2] - S[x1 - 1][y2] - S[x2][y1 - 1] + S[x1 - 1][y1 - 1]
//시간 복잡도 :
//
//사전 계산 : O(N²)
//
//쿼리 처리 : O(1)
//
//총 시간 : O(N² + M)


#include <iostream>
#include <vector>
using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int n, m;
	cin >> n >> m;
	vector<vector<int>> a(n + 1, vector<int>(n + 1));
	vector<vector<int>> d(n + 1, vector<int>(n + 1));
	for (int i = 1; i < n + 1; i++) {
		for (int j = 1; j < n + 1; j++) {
			cin >> a[i][j];
			d[i][j] = a[i][j] + d[i - 1][j] + d[i][j - 1] - d[i - 1][j - 1];
		}
	}

	for (int i = 0; i < m; i++) {
		int x1, y1, x2, y2;
		cin >> x1 >> y1 >> x2 >> y2;
		int sum = d[x2][y2] - d[x2][y1 - 1] - d[x1 - 1][y2] + d[x1 - 1][y1 - 1];
		cout << sum << "\n";
	}

}











